/******************************************************************************************************************************************************************************************************\
***
*** Description       : TEMPLATE FILE USED FROM CFG GENERATOR:
*** Codefile          : ukfCfgTemplate.c
*** Documentation     :
*** Generated by : ukfCfgGen.m
*** Generation Time/Date : 16-Dec-2019 20:42:49
***
*** MIT License
***
*** Copyright (c) 2018 ivo-georgiev
***
*** Permission is hereby granted, free of charge, to any person obtaining a copy
*** of this software and associated documentation files (the "Software"), to deal
*** in the Software without restriction, including without limitation the rights
*** to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
*** copies of the Software, and to permit persons to whom the Software is
*** furnished to do so, subject to the following conditions:
***
*** The above copyright notice and this permission notice shall be included in all
*** copies or substantial portions of the Software.
***
*** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
*** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
*** FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
*** AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
*** LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
*** OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
*** SOFTWARE.
\******************************************************************************************************************************************************************************************************/
#include "ukfCfg2.h"

//<DEFINES:BEGIN>
#define xL (uint8_t)2
#define yL (uint8_t)1
#define sL (uint8_t)5
#define uL (uint8_t)0
//<DEFINES:END>

//<STATE TRANSITION PROTOTYPE:BEGIN>
static void Fx1(Matrix_t * pu_p, Matrix_t * pX_p, Matrix_t * pX_m,uint8_t sigmaIdx, double dT);
static void Fx2(Matrix_t * pu_p, Matrix_t * pX_p, Matrix_t * pX_m,uint8_t sigmaIdx, double dT);
//<STATE TRANSITION PROTOTYPE:END>

//<MEASUREMENT PROTOTYPE:BEGIN>
static void Hy1(Matrix_t * pu, Matrix_t * pX_m, Matrix_t * pY_m,uint8_t sigmaIdx);
//<MEASUREMENT PROTOTYPE:END>

//<STATE TRANSITION PTR ARRAY:BEGIN>
static PredictFcn_t PredictFcn[xL] = {&Fx1,&Fx2};
//<STATE TRANSITION PTR ARRAY:END>

//<MEASUREMENT PTR ARRAY:BEGIN>
static ObservFcn_t  ObservFcn[yL] = {&Hy1};
//<MEASUREMENT PTR ARRAY:END>

//-----------------------
//UKF Processing matrix
//-----------------------
static double Sc_vector[1][3] = {{0.1,2,0}};
static double Wm_weight_vector[1][sL] = {{0,0,0,0,0}};
static double Wc_weight_vector[1][sL] = {{0,0,0,0,0}};


static double y_meas[yL][1] = {{0}};
static double y_predicted_mean[yL][1] = {{0}};
static double x_system_states[xL][1] = {{0},{0}};
static double x_system_states_ic[xL][1] = {{2},{0}};


static double x_system_states_correction[xL][1] = {{0},{0}};
static double X_sigma_points[xL][sL]= {{0,0,0,0,0,},{0,0,0,0,0}};
static double Y_sigma_points[yL][sL]= {{0,0,0,0,0}};
static double Pxx_error_covariance[xL][xL]= {{0,0,},{0,0}};
static double Pxx0_init_error_covariance[xL][xL]= {{1,0,},{0,1}};
static double Qxx_process_noise_cov[xL][xL]= {{0.02,0,},{0,0.1}};
static double Ryy0_init_out_covariance[yL][yL]= {{0.2}};
static double Pyy_out_covariance[yL][yL]= {{0}};
static double Pyy_out_covariance_copy[yL][yL]= {{0}};
static double Pxy_cross_covariance[xL][yL]= {{0},{0}};
static double K_kalman_gain[xL][yL]= {{0},{0}};
static double Pxx_covariance_correction[xL][xL]= {{0,0,},{0,0}};
static double I_identity_matrix[yL][yL]= {{0}};

UkfMatrix_t UkfMatrixCfg2 =
{
	{COLXROW(Sc_vector),NROWS(Sc_vector),NCOL(Sc_vector),&Sc_vector[0][0]},
	{COLXROW(Wm_weight_vector),NROWS(Wm_weight_vector),NCOL(Wm_weight_vector),&Wm_weight_vector[0][0]},
	{COLXROW(Wc_weight_vector),NROWS(Wc_weight_vector),NCOL(Wc_weight_vector),&Wc_weight_vector[0][0]},
	{COLXROW(x_system_states),NROWS(x_system_states),NCOL(x_system_states),&x_system_states[0][0]},
	{COLXROW(x_system_states_ic),NROWS(x_system_states_ic),NCOL(x_system_states_ic),&x_system_states_ic[0][0]},
	{0,0,0,NULL},
	{0,0,0,NULL},
	{COLXROW(x_system_states_correction),NROWS(x_system_states_correction),NCOL(x_system_states_correction),&x_system_states_correction[0][0]},
	{0,0,0,NULL},
	{0,0,0,NULL},
	{COLXROW(X_sigma_points),NROWS(X_sigma_points),NCOL(X_sigma_points),&X_sigma_points[0][0]},
	{COLXROW(Y_sigma_points),NROWS(Y_sigma_points),NCOL(Y_sigma_points),&Y_sigma_points[0][0]},
	{COLXROW(y_predicted_mean),NROWS(y_predicted_mean),NCOL(y_predicted_mean),&y_predicted_mean[0][0]},
	{COLXROW(y_meas),NROWS(y_meas),NCOL(y_meas),&y_meas[0][0]},
	{COLXROW(Pyy_out_covariance),NROWS(Pyy_out_covariance),NCOL(Pyy_out_covariance),&Pyy_out_covariance[0][0]},
	{COLXROW(Pyy_out_covariance_copy),NROWS(Pyy_out_covariance_copy),NCOL(Pyy_out_covariance_copy),&Pyy_out_covariance_copy[0][0]},
	{COLXROW(Ryy0_init_out_covariance),NROWS(Ryy0_init_out_covariance),NCOL(Ryy0_init_out_covariance),&Ryy0_init_out_covariance[0][0]},
	{COLXROW(Pxy_cross_covariance),NROWS(Pxy_cross_covariance),NCOL(Pxy_cross_covariance),&Pxy_cross_covariance[0][0]},
	{COLXROW(Pxx_error_covariance),NROWS(Pxx_error_covariance),NCOL(Pxx_error_covariance),&Pxx_error_covariance[0][0]},
	{COLXROW(Pxx0_init_error_covariance),NROWS(Pxx0_init_error_covariance),NCOL(Pxx0_init_error_covariance),&Pxx0_init_error_covariance[0][0]},
	{COLXROW(Qxx_process_noise_cov),NROWS(Qxx_process_noise_cov),NCOL(Qxx_process_noise_cov),&Qxx_process_noise_cov[0][0]},
	{COLXROW(K_kalman_gain),NROWS(K_kalman_gain),NCOL(K_kalman_gain),&K_kalman_gain[0][0]},
	{COLXROW(I_identity_matrix),NROWS(I_identity_matrix),NCOL(I_identity_matrix),&I_identity_matrix[0][0]},
	{COLXROW(Pxx_covariance_correction),NROWS(Pxx_covariance_correction),NCOL(Pxx_covariance_correction),&Pxx_covariance_correction[0][0]},
	&PredictFcn[0],
	&ObservFcn[0],
	0.05
};

//<STATE TRANSITION:BEGIN>
void Fx1(Matrix_t *pu_p, Matrix_t *pX_p, Matrix_t *pX_m, uint8_t sigmaIdx, double dT)
{
	const uint8_t nCol = pX_m->ncol;
	pX_m->val[nCol * 0 + sigmaIdx] = pX_p->val[nCol * 0 + sigmaIdx] + pX_p->val[nCol * 1 + sigmaIdx] * dT;
}
void Fx2(Matrix_t *pu_p, Matrix_t *pX_p, Matrix_t *pX_m, uint8_t sigmaIdx, double dT)
{
	const uint8_t nCol = pX_m->ncol;
	pX_m->val[nCol * 1 + sigmaIdx] = pX_p->val[nCol * 1 + sigmaIdx] +
		(1 - pX_p->val[nCol * 0 + sigmaIdx] * pX_p->val[nCol * 0 + sigmaIdx]) * pX_p->val[nCol * 1 + sigmaIdx] * dT - pX_p->val[nCol * 0 + sigmaIdx] * dT;
}
//<STATE TRANSITION:END>

//<MEASUREMENT FUNCTION:BEGIN>
void Hy1(Matrix_t *pu, Matrix_t *pX_m, Matrix_t *pY_m, uint8_t sigmaIdx)
{
	const uint8_t nCol = pY_m->ncol;
	pY_m->val[nCol * 0 + sigmaIdx] = pX_m->val[nCol * 0 + sigmaIdx];
}
//<MEASUREMENT FUNCTION:END>
